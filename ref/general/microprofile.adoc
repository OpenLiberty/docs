:page-layout: general-reference
:page-type: general
:page-description: Observability helps you understand system behavior by processing and monitoring the data the system generates through metrics, logging, tracing, and health checks, to get the information you need to troubleshoot failure
:page-categories: MicroProfile
:seo-title: Observability helps you understand system behavior by processing and monitoring system data
:seo-description: Microservice architecture is a popular approach for building cloud-native applications in which each capability is developed as an independent service. It enables small, autonomous teams to develop, deploy, and scale their respective services independently.
= Observability and monitoring

Observability helps you understand system behavior by processing and monitoring the data the system generates through metrics, logging, tracing, and health checks, to get the information you need to troubleshoot failure.

In a microservices environment, your application needs to be functional as a whole, though individual service instances can start or stop to adjust for capacity requirements or to recover from failure.
To monitor this fluid system each entity must provide appropriate data for problem detection.
Metrics collect numerical information from the application and platform.
Whereas, Logs collect textual information, for example, an error message generated by the application.
Tracing, on the other hand, captures the end-to-end flow of a request through the system.
Health Checks, often custom HTTP endpoints, help orchestrators, perform automated actions to maintain overall system health.

Metrics

Metrics are simple numerical measurements that are captured and processed to identify and respond to potential issues before they escalate and cause more serious problems.
In distributed system metrics, there are three factors; producers, aggregators and processors.

Producers, applications for example, can be directly involved in producing metrics, or other infrastructure passively observe or actively instrument the application to produce metrics on its behalf.
What happens next depends on the aggregator.

In the case of aggregators, for example, Prometheus, metrics are transferred from the producer to the aggregator by way of either "push" or "pull" mechanisms.
Some aggregators, expect the application to connect to the aggregator to transmit data.
The connection information for the aggregator must be distributed to all of the application processes that are measured.
Other aggregators periodically connect to a known endpoint to gather metrics data.
This requires the producer to define and provide an endpoint that can be scraped, and for the aggregator to be told where the endpoints are.
When used with Kubernetes, Prometheus can discover endpoints based on service annotations.

Processors, for example, Grafana, uses all of the aggregated data.
Services like Grafana process aggregated metrics for visualization by using dashboards.
Grafana also supports alerts by rules that are stored and evaluated independently of the dashboard.

Logs

Log messages are strings with contextual information that pertains to the state and activity of a microservice when the log entry is created.
Logs are required to diagnose how and why services fail.They play a supporting role to metrics in monitoring application health.
Handling log files requires more thought if a containerized application can't be configured to write logs to standard out or standard err.
You can use a volume for log data with a simple bind mount for local development and test, or a proper Persistent Volume as part of a Kubernetes deployment.
A dedicated sidecar or logging agent can read from a shared volume to forward logs to a centralized aggregator.
Log rotation must be configured explicitly to control the amount of log data stored on volumes.
Alternately, you can use application libraries or agents to forward logs directly to aggregators.
This option can carry some configuration complexity across deployment environments.

Tracing

Distributed, request, or end-to-end tracing captures the end-to-end flow of a request through the system.
Distributed tracing is a technique that addresses logging information in microservice-based applications.
HTTP request tracing is a feature of IIS that provides a way to determine what exactly is happening with a request.
This includes any form of authentication, which handler was used, and how long each step took in the pipeline.
Tracing essentially captures both relationships between services, the services the request touched, and the structure of work through the system, synchronous or asynchronous processing, child-of or follows-from relationships.

Health Checks

A health check is a special REST API implementation that you can use to validate the status of a microservice and its dependencies.
Services report as either UP (available) or DOWN (unavailable) by implementing the API provided by MicroProfile Health.
Health Checks, often custom HTTP endpoints, help orchestrators, like Kubernetes or Cloud Foundry, perform automated actions to maintain overall system health.

A service has an health check API endpoint (e.g. HTTP /health) that returns the health of the service.
The API endpoint handler performs various checks, such as the status of the connections to the infrastructure services used by the service instance, the status of the host, e.g. disk space, application specific logic.

A health check client - a monitoring service, service registry or load balancer - periodically invokes the endpoint to check the health of the service instance
