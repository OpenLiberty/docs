// Copyright (c) 2020 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:page-description: Open Liberty is a lightweight Java runtime for building cloud-native applications and microservices.
:page-layout: general-reference
:seo-title: About Open Liberty
:seo-description: Open Liberty is a lightweight Java runtime for building cloud-native applications and microservices.
:page-layout: general-reference
:page-type: general
= About Open Liberty

Open Liberty is a lightweight Java runtime for building cloud-native applications and microservices.

With Open Liberty, you can add and remove modular features from the latest versions of Eclipse MicroProfile and Jakarta EE.
This modular structure simplifies application development, so you run only the features that your application needs.
Furthermore, thanks to zero-migration architecture, you can upgrade to the latest version of Open Liberty with minimal impact to your current applications and configurations.
Open Liberty is compatible with MicroProfile and with the Jakarta EE Full Platform and Web Profile specifications.
For updates about Open Liberty features and capabilities, see the link:https://openliberty.io/blog/[Open Liberty blog] and https://openliberty.io/docs/[Open Liberty docs].

Open Liberty provides a diverse library of interactive and static developer guides that are designed to give you firsthand experience with the configuration and features that support cloud-native development.
The guides cover a wide range of development and production scenarios and can be adapted as reference templates for developing your own applications. link:/guides/[Browse the guides] and learn how to build, package, and deploy applications and microservices with Open Liberty.


== Develop cloud-native Java applications and microservices

Open liberty is designed to simplify and accelerate application development. Open Liberty offers a low-memory footprint and some of link:/blog/2019/10/30/faster-startup-open-liberty.html[the fastest start-up times of any lightweight Java server]: one second or less for simple configurations on processors that are used in current laptops and servers.
Faster start-up times enable faster development and test cycles.

=== Mix and match features
Open Liberty features are pluggable, so that your existing features are supported in new product versions. You can add, remove, and update features as needed, with minimal impact to your application. When the feature configuration is changed, Open Liberty reevaluates the code by starting and stopping parts of the runtime as necessary, without having to restart the server. For a full list of available features and their configuration elements, see link:/docs/ref/feature/#featureOverview.html[Server features].

You can freely mix MicroProfile, Jakarta EE, and other features, according to the needs of your applications. Open liberty maintains regular 4-weekly releases, so new versions of features are available quickly. For more information, see link:/docs/ref/general/#microprofile.html[MicroProfile simplifies developing cloud-native Java microservices].

=== Deploy, test and debug in development mode
Run your server in development mode, or link://blog/2019/10/22/liberty-dev-mode.html[dev mode], for automatic reload and deployment, on-demand testing, and debugger support.
With dev mode, Open Liberty automatically detects changes in your code, compiles them, and deploys them to your running server.
You can run tests on demand, or even automatically, so that you get immediate feedback on your changes.

=== Develop with zero migration
With Open Liberty zero-migration architecture, you focus on writing your applications, not the APIs changing under you.
Zero-migration architecture means that you can use existing, unmodified configuration and application files with an updated version of Open Liberty, without unexpected changes in behavior.
Open Liberty offers full compatibility between product versions so that your existing APIs and behaviors are supported in each new release. For more information, see link:/guides/getting-started.html[Packaging and deploying applications].


== Deploy in containers to any cloud

Open Liberty can be containerized and deployed to any Kubernetes cloud. Check out these guides to learn how you can easily deploy to link:/guides/okd.html[OKD], link:/guides/cloud-openshift.html[OpenShift], link:/guides/cloud-azure.html[Azure Kubernetes Service], link:/guides/cloud-aws.html[Amazon Web Services], link:/guides/cloud-ibm.html[IBM Kubernetes Service], and more.

=== Protect applications and servers
Open Liberty supports application security with a robust set of security features.
During development and testing, Open Liberty's built-in link:/docs/ref/general/#basic-registry.html[basic user registry and the QuickStart security element] offer easily configurable security frameworks to test access to your application in a lightweight, self-contained manner.
The `securityUtility` supports plain text encryption, so you can easily secure user passwords with hash encoding.

After deployment, the link:/docs/ref/feature/#appSecurity.html[Application Security] feature provides the core capability for the Jakarta EE Security API, while the link:/docs/ref/feature/#transportSecurity.html[Transport Security] feature enables secure TLS connections by using HTTPS.
The link:/docs/ref/feature/#ldapRegistry.html[LDAP User Registry] feature supports authentication and authorization from external LDAP registries.
Open Liberty also provides features to support a range of single sign-on options, including link:/docs/ref/feature/#jwtSso.html[JSON Web Tokens], link:/docs/ref/feature/#jwtSso.html[OpenID Connect], link:/docs/ref/feature/#samlWeb.html[SAML Web], and link:/docs/ref/feature/#spnego.html[SPNEGO].

=== Optimize throughput
A properly tuned thread pool can maximize throughput, reduce response times, and increase the capacity for concurrent requests.
Application code in Open Liberty runs in a single thread pool that is called the default executor.
The size of this pool is set by link:/docs/ref/general/#thread-pool-tuning.html[an auto-tuning controller], which can manage a wide range of workloads.


=== Deploy with zero migration
Zero migration is the ability to use existing, unmodified user files with an updated version of the product runtime files, without any unwanted or unexpected changes in behavior. Open Liberty does not modify user configuration files, which are fully compatible between versions.
You can use a single version of your configuration files across multiple versions.
Files that you created for a previous version of Open Liberty can be used with a later version.
Files that you create for later versions can be used with previous versions.
As a result, if all configured features are installed, you can use a single set of configuration files across multiple versions without modifications.

=== Separate configuration from code
Open Liberty follows a principle of configuration by exception, which allows for succinct config files.
The runtime environment operates from a set of built-in config default settings.
You specify config only when you want to override the default settings.
Open Liberty monitors the server XML config for updates and dynamically reloads whenever changes are detected.
For more information, see link:/docs/ref/config/#serverConfiguration.html[Server configuration].

Throughout the development, testing, and production lifecycle of your application, you can easily specify changes to configuration according to the deployment context. With MicroProfile Config, you can build your app once and deploy it many times through your CI/CD pipeline by changing the configuration for each deployment. For more information, see link:/guides/microprofile-config.html[Configuring microservices].


== Monitor applications in the cloud

Distributed tracing helps you track the flow of a request as it moves through an application.
Tracing creates observability, so you can debug errors and better understand throughput. With Open Liberty, it's simple to implement a standard system to trace requests through an application and record the results to customizable logs.

=== Customize logs
You can specify custom fields in your Open Liberty logs to capture detailed information about specific requests, users, or behaviors. Custom fields can help sort and filter your logs, so you can better understand what's happening in your application. For more information, see link:https://openliberty.io/blog/2019/12/03/custom-fields-json-logs.html[
Adding custom fields to JSON logs in Open Liberty].

=== Gather and analyze metrics
You can link:/docs/ref/general/#microservice_observability_metrics.html[gather detailed metrics on your applications] that run on Open Liberty with MicroProfile metrics. Metrics are essential to building observability into applications so that operations teams can monitor application behavior effectively. After you configure metrics, you can link:/blog/2020/01/29/alerts-slack-prometheus-alertmanager-open-liberty.html[get alerts from your Open Liberty apps in Slack using Prometheus Alertmanager]. You can also link:blog/2020/01/23/Kibana-dashboard-visualizations.html[compile the data from your logs into visualizations in dashboards like Kibana] to spot potential problems in your Open Liberty server in real time.
