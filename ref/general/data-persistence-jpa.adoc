// Copyright (c) 2020 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:page-description:
:seo-title: Data persistence with the Java Persistence API (JPA)
:seo-description:
:page-layout: general-reference
:page-type: general
= Data persistence with the Java Persistence API

The Java Persistence API (JPA) simplifies data persistence and object relational mapping for Java applications. With JPA, applications can efficiently create, read, update, and delete objects from a relational database.

Persistent data is data that outlives the application process that created it. Applications commonly persist data in relational databases, which organize data in sets of tables with columns and rows. Many different types of relational databases exist, and their configurations vary. JPA provides a standard for applications to interact with relational databases so that developers don't need to worry about vendor-specific differences or writing time-consuming boilerplate code to persist data.

== What is JPA?

Enterprise applications require efficient access to relational databases. For example, an event calendar application needs to create, retrieve, update, and delete the events that users add to their calendar. The application itself can't efficiently store this data and must be able to quickly retrieve it from a database, complete the requested function, and if necessary, return it to persistent storage. In the past, configuring these tasks required developers to manage complex SQL operations and differences among vendor databases. JPA provides an extra level of abstraction between the application and the database, enabling developers to manage data persistence in a standardized way, by using annotations or XML.

JPA is a Jakarta EE specification to represent data in relational database tables as Plain Old Java Objects (POJO), a process that is known as object-relational mapping (ORM). JPA simplifies and standardizes ORM by using annotations or XML to map Java objects into one or more tables of a relational database. The JPA specification explicitly defines ORM, rather than relying on vendor-specific mapping implementations. JPA is based on the Java programming model that applies to Java Enterprise Edition (Jakarta EE) environments, but it can function within a Java SE environment for testing application functions.

////
removing from topic per SME review

=== Entities and persistence context

The Java objects that a JPA implementation persists to a database are called entities. An entity is a simple Java class that represents a row in a database table. They maintain states by using properties or fields. Entities are managed within a persistence context. A persistence context acts as a cache where entities that are modified by application processes are stored until they are flushed back to the persistent storage. Persistence contexts can be either transaction-scoped or extended-scoped. If a persistence context is transaction-scoped, entities are flushed to persistent storage as soon as the transaction completes. If the persistence context is extended-scoped, entities can span multiple transactions.

JPA is designed to operate both inside and outside of a Jakarta EE container. When you run JPA inside a container, applications can use the container to manage the persistence context. If there is no container, the application must handle the persistence context management itself. Applications that are designed for container-managed persistence do not require as much code implementation to handle persistence, but these applications cannot be used outside of a container. Applications that manage their own persistence can function in a container environment or a Java SE environment.

=== The EntityManager API

The JPA specification defines an EntityManager API, which can persist, update, retrieve, or remove objects from a database. The EntityManager API is a resource manager that maintains the active collection of entity instances that are used by the application. Each EntityManager instance is associated with a persistence context. A persistence context defines the scope under which particular entity instances are created, persisted, and removed by the EntityManager API.

The EntityManager tracks all entities within a persistence context for changes and updates and flushes these changes to the persistent storage database. After a persistence context closes, all managed entities become detached from the persistence context and its associated EntityManager. After an entity is detached from a persistence context, it is no longer managed by an EntityManager, and state changes are not synchronized with the database.

=== Persistence units and the EntityManagerFactory interface

An application in a container can obtain the EntityManager through injection into the application or by looking it up in the Java component namespace. If the application manages its own persistence, the EntityManager is obtained from the EntityManagerFactory interface. This interface draws on declarative metadata that describes the relationship of entity class objects to a relational database. This data is known as a persistence unit, and the EntityManagerFactory interface uses it to create a persistence context that that can be accessed through the EntityManager instance.

////

=== JPA and JDBC

The Java Database Connectivity API (JDBC) handles the actual communication between an application and the tables in a relational database by managing SQL queries and commands. JPA provides a level of abstraction between the application and JDBC layers, allowing developers to manage persistence with Java annotations or XML, without having to worry about the details of SQL functions. Although managing persistence at the JDBC level provides more flexibility and fine-grained control over how data is persisted, it is much more complex to configure and maintain.

Whether you manage persistence through JPA or directly with JDBC depends on the needs of your application. Developers might prefer to work directly with JDBC if their application doesn't have much interaction with a database or doesn't need to support many different database vendors. However, working directly with JDBC requires familiarity with SQL. Developers who are not familiar with SQL, or whose applications need to support complex data models or multiple database vendors, might choose to manage persistence with JPA.

// For more information about JDBC, see [link pending].

== JPA configuration with Open Liberty

JPA for Open Liberty is supported by the JPA feature, version 2.1 and later, and the JPA Container feature, version 2.1 and later. The JPA feature includes JPA specification interfaces and container-managed JPA integration. EclipseLink is included as the default JPA provider implementation. If you want to use different a provider implementation, such as Hibernate, enable the JPA Container feature. The JPA Container feature provides the same capabilities as the JPA feature but does not include a default provider implementation.

If you enable the JPA feature, you do not need to enable the JPA Container feature. The JPA feature automatically enables the JPA Container feature.

For more information, see link:/docs/ref/feature/#jpa.html[the JPA feature]. For examples of how to configure a provider implementation other than the default, see link:/docs/ref/feature/#jpaContainer.html[the JPA Container feature].

== See also

Ready to try out JPA with Open Liberty? Check out the guide to link:/guides/jpa-intro.html[Accessing and persisting data in microservices using JPA].
