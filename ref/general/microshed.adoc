:page-layout: general-reference
:page-type: general
:page-description: MicroShed testing helps you to write integration tests using Testcontainers framework for Java microservice applications. With MicroShed testing you can test your Open Liberty application from outside the container so you are testing the exact same image that runs in production.
:page-categories: MicroShed testing
:seo-title: Testing in a container with MicroShed testing
:seo-description:  MicroShed testing helps you to write integration tests using Testcontainers for Java microservice applications. With MicroShed testing you can test your Open Liberty application from outside the container so you are testing the exact same image that runs in production.
= Testing microservice applications

MicroShed Testing is a Java library that helps you write true-to-production integration tests for your applications.
The tests are run against the same image that runs in production to ensure that your application is being tested in the same way throughout the development process.
link:https://microshed.org/microshed-testing/[MicroShed Testing] uses the link:https://openliberty.io/blog/2019/03/27/integration-testing-with-testcontainers.html[Testcontainers] framework to analyze your application from outside the link:https://www.docker.com/why-docker[Docker] container without accessing the application internals. You can use MicroShed Testing to develop integration tests for your Open Liberty application.

== Why integration testing

You need to be sure that your application works as well in production as it does in the development environment.
Integration tests assess multiple test classes and components, but take longer and can be complicated to set up and configure.
Alternately, unit tests involve testing individual modules of an application and are shorter and less complicated to run.
With shorter development cycles and limited time available, developers often run unit tests.
MicroShed Testing helps to write and run integration tests for your applications and streamlines your integration tests with the Testcontainers framework for an efficient workflow.

== Development and production parity

Development and production parity, or link:https://12factor.net/dev-prod-parity[dev/prod parity], is one of the factors in the link:https://12factor.net/[twelve-factor app], a methodology to build modern applications.
The idea behind dev/prod parity is to keep the development, staging, and production environments as similar as possible in terms of time, personnel, and tools.
To simplify the development process, developers often use different tools in development than they do in production.
For example, you might use a local Maven build in development, but the application might be deployed to a Docker container in production.
Differences between the environments can cause a test to fail in production, even though it passed in development.
So it is important to use the same services in development as in production.
MicroShed Testing framework helps achieve dev/prod parity because it tests the application by using the same environment that is used in production.

== Write integration tests with Microshed Testing

You can deploy your microservices in different environments by using containers.
With Testcontainers framework, you can use containers in a test environment.
Microshed Testing is a Java library for MicroProfile and link:https://jakarta.ee/[Jakarta EE] developers to test their applications in an environment similar to production.
Microshed Testing implements Testcontainers to support dev/prod parity in testing.

With MicroShed Testing framework, you can write an integration test that looks something like this:

```java

@MicroShedTest
public class BasicJAXRSServiceTest {

    @Container
    public static ApplicationContainer app = new ApplicationContainer()
                    .withAppContextRoot("/myservice");

    @RESTClient
    public static PersonService personSvc;

    @Test
    public void testGetPerson() {
        Long bobId = personSvc.createPerson("Bob", 24);
        Person bob = personSvc.getPerson(bobId);

        assertEquals("Bob", bob.name);
        assertEquals(24, bob.age);
        assertNotNull(bob.id);
    }

    @Test
    public void testGetUnknownPerson() {
        assertThrows(NotFoundException.class, () -> personSvc.getPerson(-1L));
    }
}
```
The `@MicroShedTest` annotation searches for a Dockerfile in the repository, starts up the application in a Docker container, and waits for it to be ready before the test starts.
The `@Container` annotation injects a REST Client proxy of the PersonService, which helps you send HTTP requests on the running application container.
The `@RESTClient` annotation sends an HTTP POST request to the running container, which triggers the PersonService#createPerson endpoint and returns the generated ID.
By using the generated ID, send an HTTP GET request to read the record that was created. The JSON response automatically converts to a Person object by using JSON-B token.
The `@Test` annotation sends an HTTP GET request to get a person with ID `-1`, which does not exist. The annotation asserts that the application container returns an HTTP 404 exception.

== Where to next

Ready to try MicroShed Testing to test a MicroProfile or Jakarta EE application? Check out the guide https://openliberty.io/guides/microshed-testing.html[Testing a MicroProfile or Jakarta EE application]
