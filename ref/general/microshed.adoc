:page-layout: general-reference
:page-type: general
:page-description: MicroShed testing helps you to write integration tests using Testcontainers framework for Java microservice applications. With MicroShed testing you can test your Open Liberty application from outside the container so you are testing the exact same image that runs in production.
:page-categories: MicroShed testing
:seo-title: Testing in a container with MicroShed testing
:seo-description:  MicroShed testing helps you to write integration tests using Testcontainers for Java microservice applications. With MicroShed testing you can test your Open Liberty application from outside the container so you are testing the exact same image that runs in production.
= Testing microservice applications

MicroShed Testing is a Java library that helps you write true-to-production integration tests for your microservice applications with the link:https://openliberty.io/blog/2019/03/27/integration-testing-with-testcontainers.html[Testcontainers] framework.
link:https://microshed.org/microshed-testing/[MicroShed Testing] analyzes your application from outside the link:https://www.docker.com/why-docker[Docker] container without accessing the application internals.

You can use MicroShed Testing to develop integration tests for your Open Liberty application.
Test your application from outside its container so that the tests run against the same image that you use in production.

== Why integration testing

You need to be sure that your application works as well in production as it does in the development environment.
Integration tests assess multiple test classes and components, but take longer and can be complicated to set up and configure.
Alternately, unit tests involve testing individual modules of an application and are shorter and less complicated to run.
With shorter development cycles and limited time available, developers often run unit tests.
MicroShed Testing streamlines your integration tests with the Testcontainers framework for an efficient workflow.

== Development-production parity

Development-production parity, or dev/prod parity, is one of the factors in the link:https://12factor.net/ [twelve-factor app], a methodology to build modern applications.
The idea behind dev/prod parity is to keep the development, staging, and production environments as similar as possible in terms of time, personnel, and tools.
To simplify the development process, developers often use different tools in development than they do in production.
For example, you might use a local Maven build in development, but the application might be deployed to a Docker container in production.
Differences between the environments can cause a test to fail in production, even though it passed in development.
So it is important to use the same services in development as in production.
MicroShed Testing framework helps achieve dev/prod parity because it tests the application by using the same environment that is used in production.

== Writing integration tests with Microshed Testing

You can deploy your microservices in different environments by using containers.
With the Testcontainers framework, which is an open source library that supports JUnit tests, you can use containers in a test environment.
Microshed Testing is a Java library for MicroProfile and Java EE developers to test their applications in an environment similar to production.
Microshed Testing implements Testcontainers to support dev/prod parity in testing.

With MicroShed Testing framework, you can write an integration test that looks something like this:

[source, java]
----
@MicroShedTest
public class BasicJAXRSServiceTest
----

The @MicroShedTest annotation searches for a Dockerfile in the repository, starts up the application in a Docker container, and waits for it to be ready before starting the tests.

    @Container
    public static ApplicationContainer app = new ApplicationContainer()
                    .withAppContextRoot("/myservice");

The @Container annotation injects a REST _Client_ proxy of the PersonService, which allows you to easily invoke HTTP requests on the running application container.

    @RESTClient
    public static PersonService personSvc;

    @Test
    public void testGetPerson()

The @RESTClient annotation invokes an HTTP POST request to the running container, which triggers the PersonService#createPerson endpoint and returns the generated ID
        Long bobId = personSvc.createPerson("Bob", 24);

By using the generated ID, invoke an HTTP GET request to read the record that was created. The JSON response automatically converts to a `Person` object by using JSON-B.

        Person bob = personSvc.getPerson(bobId);

        assertEquals("Bob", bob.name);
        assertEquals(24, bob.age);
        assertNotNull(bob.id);


    @Test
    public void testGetUnknownPerson()

The @Test annotation invokes an HTTP GET request to get a person with ID -1, which does not exist
         and asserts that the application container returns an HTTP 404 (not found) exception

        assertThrows(NotFoundException.class, () -> personSvc.getPerson(-1L));


== Where to next

Ready to try MicroShed Testing to test a MicroProfile or Jakarta EE application? Check out the guide https://openliberty.io/guides/microshed-testing.html[Testing a MicroProfile or Jakarta EE application]
