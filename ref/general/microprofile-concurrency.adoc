// Copyright (c) 2018 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:page-layout: general-reference
:page-type: general
= MicroProfile Context Propagation in Open Liberty builds

Completion stages and completable futures (introduced in Java SE 8) enable the chaining together of pipelines of dependent actions with the ability to run sequentially or in parallel, depending on how the API is used. Execution of a dependent stage is triggered by the completion of the stage (or stages) upon which it depends. While this capability provided by completion stages can be useful in enabling applications to implement a model where they react to events as they happen, the built-in implementation (completable future) neglects several important areas: consistency and reliability of thread context and defaulting asynchronous dependent stage actions to run on the Liberty global thread pool. MicroProfile Context Propagation provides a `ManagedExecutor` and `ThreadContext` API to address these problems. An implementation of the MicroProfile Context Propagation specification is now available in the https://openliberty.io/downloads/[Open Liberty development builds].

Managed Executors in MicroProfile Context Propagation use completion stages that run with predictable thread context regardless of which thread the action ends up running on. Without this feature, the thread context of a completion stage action depends on whether the action runs randomly on either
the requesting thread, the thread of a stage that it depends on, a thread that is requesting the result, or a thread that forcibly completes the prior stage. However, with MicroProfile Context Propagation, the thread context is deterministic because context is always captured from the thread that creates
the completion stage and applied when running the action.

Alternatively, you can configure to clear certain context types rather than capturing context. For example, clearing the security context means that no user is associated with the thread while the completion stage action runs. When a completion stage is created by a managed executor, the
managed executor remains associated with the completion stage to determine thread context propagation and for dependent stages that are requested to run asynchronously without designating a specific executor. The managed executor remains associated with each subsequent dependent stage
created allowing for predictable thread context propagation at every stage in the pipeline.

For example, a managed executor can be used to propagate the application's namespace to an asynchronous action:
----
CompletableFuture<Integer> stage = executor.supplyAsync(supplier1)
    .thenApply(function1)
    .thenApply(function2)
    .thenApply(i -> {
        try {
            DataSource ds = InitialContext.doLookup("java:module/env/jdbc/ds1");
            ...
            return result;
        } catch (Exception x) {
           throw new CompletionExeption(x);
        }
    });
----

Managed executors in MicroProfile Context Propagation are fully compatible with `ManagedExecutorService` in Java EE Concurrency, leaving open the possibility that the programming models might one day be merged. Notably, the ``org.eclipse.microprofile.context.ManagedExecutor`` interface inherits from
`java.util.concurrent.ExecutorService`, and thus allows the same execute/submit/invoke operations as `ManagedExecutorService`.


MicroProfile Context Propagation provides the `org.eclipse.microprofile.context.ThreadContext` interface to facilitate the use of unmanaged completion stages. When you have a completion stage that isn't created by a managed executor, it can still run with predictable thread context if you pre-contextualize its action with
the corresponding method of MicroProfile Context Propagation `ThreadContext`. For example,
----
CompletableFuture<Long> stage = CompletableFuture.supplyAsync(supplier1)
    .thenApplyAsync(function1)
    .thenApply(threadContext.contextualFunction(function2));
----

To enable the MicroProfile Context Propagation 1.0 feature in your server.xml file:
----
<featureManager>
  <feature>mpContextPropagation-1.0</feature>
  <feature>cdi-2.0</feature> <!-- optional, used in example -->
  <feature>jndi-1.0</feature> <!-- optional, used in example -->
  ... other features
</featureManager>
----

== How to obtain ManagedExecutor and ThreadContext instances

Instances of `ManagedExecutor` and `ThreadContext` are obtained in various ways.

* MicroProfile Context Propagation offers a fluent builder pattern for programmatic
usage:
----
ManagedExecutor executor = ManagedExecutor.builder()
    .maxAsync(10)
    .propagated(ThreadContext.APPLICATION, ThreadContext.SECURITY)
    .cleared(ThreadContext.ALL_REMAINING)
    .build();
----

Applications are expected to shut down executor instances that they build when the executor instance is no longer needed.

* If you are using EE Concurrency, you can cast your existing `ManagedExecutorService` to `ManagedExecutor`.

== Integration with CDI

Application scoped CDI producers can be used in combination with the builders as a convenient way to share single instances of `ManagedExecutor` and `ThreadContext` across an application and manage their lifecycle.

Example CDI qualifier, which is used to identify which instance you want injected:
----
@Qualifier
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER })
public @interface AppAndSecurityContext {}
----

Example producer field and disposer method, defined in a CDI bean,
----
@Produces @ApplicationScoped @SecurityAndAppContext
ManagedExecutor executor = ManagedExecutor.builder()
    .propagated(ThreadContext.SECURITY, ThreadContext.APPLICATION)
    .build();

void disposeExecutor(@Disposes @SecurityAndAppContext exec) {
    exec.shutdownNow();
}
----

Example injection points, defined in one or more CDI beans,
----
@Inject @SecurityAndAppContext
ManagedExecutor exec1;
----
