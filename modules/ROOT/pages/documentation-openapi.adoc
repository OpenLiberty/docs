// Copyright (c) 2019 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:page-description: OpenAPI is a standardized mechanism for developers to describe REST APIs  for generating structured documentation in a microservice.
:seo-description: OpenAPI is a standardized mechanism for developers to describe REST APIs  for generating structured documentation in a microservice.
:page-layout: general-reference
:page-type: general
= API documentation with OpenAPI

MicroProfile OpenAPI is a MicroProfile community programming model for the OpenAPI specification.
MicroProfile OpenAPI helps you to generate structured documentation from your JAX-RS applications.

Structured documentation helps other microservices and developers to understand and communicate with your application.
Other developers need relevant information to write a vice that communicates with the REST API of your application.
MicroProfile OpenAPI facilitates this communication by generating human and machine-readable documentation on a simple interface without the need to access the source code.
You can implement MicroProfile OpenAPI for Open Liberty by enabling the feature:mpOpenAPI[display=MicroProfile OpenAPI] feature.

The two main approaches to generate an OpenAPI document are, the code-first approach and the design-first approach.
In the code-first approach, a developer can generate documentation of the REST API from the source code.
Therefore, developers donâ€™t need to rewrite portions of the OpenAPI document that are already covered by the JAX-RS framework.
The reference document that is produced lists all the API endpoints with descriptions of how to use them.
Alternatively, in the design-first approach, you can include a pre-generated OpenAPI document that was written separately from the code.
You can also use a set of predefined models to manually create all elements of the OpenAPI tree.
Additionally, you can generate the stubs for the source code, including client libraries for the API, from this manually created documentation.

== The code-first approach

In the code-first approach, you can initially generate basic API documentation of the REST API from annotations that are specified in the source code; the JAX-RS annotations are processed by default.
Then, you can augment the existing JAX-RS annotations with OpenAPI annotations, which are processed to generate the documentation.
Adding annotations takes less work than manually defining the OpenAPI document, and gives a useful explanation of the different parts of the API.

In the following example, the OpenAPI annotations `@APIResponses`, `@Operation`, and `@Parameter` are added to the JAX-RS method `purchaseCar()`.

[source,java]
----

@PUT
 @Path("/buy/{registration}")
 @Produces(MediaType.APPLICATION_JSON)
 @Consumes(MediaType.TEXT_PLAIN)
 @APIResponses(
         value = {
             @APIResponse(
                 responseCode = "404",
                 description = "The requested car could not be found at the dealership, and could not be purchased.",
                 content = @Content(mediaType = "text/plain")),
             @APIResponse(
                 responseCode = "200",
                 description = "The requested car was successfully purchased.",
                 content = @Content(mediaType = "application/json"))})
     @Operation(
         summary = "Purchases the specified car from the dealership, and adds the car to your garage.",
         description = "Retrieves the car with the specified registration from the dealership if it exists, and
                        adds this to the caller's garage. The boolean response represents the state of the internal operation.")
 public Response purchaseCar(
    @Parameter(
              description = "The registration of the car to be added to the inventory.",
              required = true,
              example = "NX15 9012",
              schema = @Schema(type = SchemaType.STRING))
    @PathParam("registration") String registration) {
  boolean success = manager.purchaseCar(registration);
     if (!success) {
         return Response.status(Response.Status.NOT_FOUND)
                        .entity("{ \"error\" : "
                                + "\"The car with registration " + registration
                                + " could not be added to the inventory\" }")
                        .build();
     }
     return Response.ok(success).build();
 }
----

Following is the corresponding OpenAPI document that is generated in a YAML format:

[source,java]
----
/my-garage/buy/{registration}:
   put:
     summary: "Purchases the specified car from the dealership, and adds the car\
       \ to your garage."
     description: "Retrieves the car with the specified registration from the dealership\
       \ if it exists, and adds this to the caller's garage. The boolean response\
       \ represents the state of the internal operation."
     parameters:
     - name: registration
       in: path
       description: The registration of the car to be added to the inventory.
       required: true
       schema:
         type: string
       example: NX15 9012
     responses:
       "404":
         description: "The requested car could not be found at the dealership, and\
           \ could not be purchased."
         content:
           text/plain: {}
       "200":
         description: The requested car was successfully purchased.
         content:
           application/json: {}
----

The information that is provided through the OpenAPI annotations augments the basic API documentation that is generated by the JAX-RS framework.

See the xref:reference:javadoc/microprofile-3.3-javadoc.adoc#package=org/eclipse/microprofile/openapi/annotations/package-frame.html&class=org/eclipse/microprofile/openapi/annotations/package-summary.html[MicroProfile OpenAPI Javadoc] for the annotations that are available.

== The design-first approach

An alternative approach is to design the REST API in an editor to begin with, such as the link:https://editor.swagger.io/[Swagger editor], before you write any code.
With this approach, you can spot and rectify any issues in the design before implementation.
In large companies, it is important to have consistent and usable APIs, which can be reviewed by subject matter experts to verify the quality of the API design.
This API design then forms a contract and must be implemented as agreed.

You can write this API design in YAML or JSON, which can then be used to generate the documentation.
Optionally, you can even create stubs for the API code.
You can then also augment the documentation with annotations in the code as described.

For more information, see https://openliberty.io/guides/microprofile-openapi.html#using-pregenerated-openapi-documents[Using pregenerated OpenAPI documents].

== Filter components in and out of API documentation

Filters give the users the flexibility to modify the document.
With link:https://download.eclipse.org/microprofile/microprofile-open-api-1.1.2/microprofile-openapi-spec.html#_filter[filters], you can implement an interface in your application.
So when a component of the documentation is processed, it calls your implementation and you can either add or remove content.

== Viewing and formatting API documentation

The documentation that is generated for the REST API is available at the `/openapi` endpoint of your application.
You can view the documentation by pointing a browser at the `/openapi/ui` endpoint.

== See also

link:/guides/microprofile-openapi.html[Guide: Documenting RESTful APIs]
link:https://download.eclipse.org/microprofile/microprofile-open-api-2.0/microprofile-openapi-spec-2.0.html#release_notes_20[Release Notes for Microprofile OpenAPI 2.0]
