// Copyright (c) 2020 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:page-description: Caching sessions in your applications helps improve performance and availability for the users.
:seo-title: Distributed session caching
:seo-description: Caching sessions in your applications helps improve performance and availability for the users.
:page-layout: general-reference
:page-type: general
= Distributed session caching

Caching HTTP sessions in your applications helps to improve performance and availability for the users.
The `sessionCache` feature in Open Liberty provides failover of non-persistent user session data with the distributed in-memory Http session caching.

You can store sessions locally on a server, on a relational database, or in the in-memory storage of your application.
However, a cached session on the server can be lost if the application instance fails.
Also, a relational database might not be part of your application architecture.
With distributed caching, the server or database doesn't need to store a cached session, as compared to non-distributed caching, which needs dedicated resources.

The `sessionCache` feature in Open Liberty provides distributed in-memory HttpSession caching.
The `sessionCache` feature builds on top of an existing technology called link:https://hazelcast.com/glossary/jcache-java-cache/[JCache] that offers a standardized distributed in-memory caching API.
Though the feature builds on top of JCache, no direct usage of JCache API is necessary in your application, since Open Liberty handles the session caching in the web container layer.


== Session caching in your application

Distributed session caching with the `sessionCache` feature works the same way as non-distributed session caching in an application.
If your application already caches data, no code changes are needed to include the `sessionCache` feature.
The following example shows what the HTTP session caching might look like.
If the `dbThing` object is not found in session, it can be obtained from the database and cached for future use.

[source, java]
----
@WebServlet("/ExampleServlet")
public class ExampleServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp)
      throws ServletException, IOException {
        HttpSession session = req.getSession();
        Object dbThing = session.getAttribute("dbThing");
        if (dbThing == null) {
            dbThing = getFromDB();
            session.setAttribute("dbThing", dbThing);
        }
    }
}
----
You need to join at least two servers together to benefit from the `sessionCache` feature.

== Joining multiple servers together

.Distributed session caching
image::blog_sessionCache.png[diagram that shows multiple liberty servers that share a persisted session cache,align="center"]

The diagram shows how multiple liberty servers can share a persisted session cache.
Each server stores a local session cache in-memory on the server.
By using an underlying JCache provider like Hazelcast, those sessions are persisted.
So when a new server starts up in a cloud environment, it has access to sessions created by other servers.

Besides the open source Hazelcast implementations that you can also use other implementations like, WebSphere eXtreme Scale, Infinispan, and Ehcache.


The `sessionCache` feature is only useful when it is connected to at least one other server.
Open Liberty server can behave in two different ways in a cluster.


. Client-Server model: A Liberty server can act as the JCache client and connect to a dedicated JCache server.

. Peer-to-Peer model: A Liberty server can connect with other Liberty servers that are also running with the `sessionCache` feature and configured to be part of the same cluster.

The following code shows a simple example of how two Liberty servers might share information that is cached in an Http session.
The first example shows the application running on Server A and the second example shows the application running on Server B:

[source, java]
----
@WebServlet("/ServiceA")
public class ServiceA extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp)
      throws ServletException, IOException {
        HttpSession session = req.getSession();
        session.setAttribute("foo", "bar");
    }
}
----

[source, java]
----
@WebServlet("/ServiceB")
public class ServiceB extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        HttpSession session = req.getSession();
        String result = session.getAttribute("foo");
        System.out.println("Session attribute foo=" + result);
    }

}
----

Each JCache implementation configures the cluster instances independently.

For Hazelcast, a simple configuration file might look like the following example.
However, you donâ€™t need to specify a Hazelcast configuration file if the default Hazelcast configuration works for you.
You can optionally create a Hazelcast configuration file, as shown in the following example, and xref:reference:feature/sessionCache-1.0.adoc#_minimum_configuration_to_persist_session_data_with_hazelcast_as_the_jcache_provider[add a reference to the Hazelcast configuration file] in your `server.xml` file:

[source, java]
----
<hazelcast xsi:schemaLocation="http://www.hazelcast.com/schema/config hazelcast-config-3.9.xsd"
           xmlns="http://www.hazelcast.com/schema/config"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">

  <group>
    <name>myCluster</name>
    <password>super-secret</password>
  </group>
</hazelcast>
----

Specifying the 'myCluster' group name causes the Hazelcast instance to connect only with other instances that are also named 'myCluster'.
