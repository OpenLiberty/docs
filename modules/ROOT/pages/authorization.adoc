// Copyright (c) 2020 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:page-description:
:seo-title: Authorization in Open Liberty
:seo-description: Authorization determines which resources a user can access in an application.
:page-layout: general-reference
:page-type: general
= Authorization

For an application to be secure, it must manage access to protected resources. Authorization determines which resources a user can access.

In applications where only certain users are entitled to access certain resources, users and groups are assigned roles that correspond to the resources that they can access. Authorization is the process by which an application determines a user's role and the permissions that role includes.
For example, in a payroll application, users in the `Employee` role can view a page that lists their hourly wages and hours worked.
However, only users in the `Manager` role can edit employee wages.
During xref:authentication.adoc[authentication], Open Liberty identifies users and determines what access groups they belong to.
When a user attempts to access a protected resource on the server, this information determines whether the user is authorized to access the resource.

== Define roles in your application code

You can specify which roles can access an application resource by setting the `@RolesAllowed` annotation in the source code to contain the permissible roles, as shown in the following example:

[source,java]
----
@RolesAllowed({ "admin", "user" })
----

You can map the roles that are declared in the application to existing groups from a user registry or SSO identity provider. Specify the `security-role` element within the `application-bnd` element in the `server.xml` file, as shown in the following example:

[source,xml]
----
<application-bnd>
   <security-role name="admin">
     <group name="Manager" />
     <group name="TeamLead" />
   </security-role>
   <security-role name="user">
     <group name="Employee" />
   </security-role>
</application-bnd>
----

The `name` attribute of the `security-role` element corresponds to a role that is specified in the application. The `name` attribute of the `group` elements correspond to the groups that are specified by a user registry or SSO identity provider.
If the role names match the group names exactly, the server maps the group to the role with a matching name by default.
If you use this default mapping, you do not need to specify an `application-bnd` element in the `server.xml` file.

In some cases, an application needs to know only the userâ€™s authentication status.
In such cases, you can specify `**` as the role name in the `@RolesAllowed` annotation.
This value denotes that any authenticated user can access a resource.
Alternatively, you can authorize all users by setting the `@PermitAll` annotation, which specifies that anyone can access a resource, even users who are not authenticated.

For more information, see the link:/guides/microprofile-jwt.html#securing-the-system-service[Securing the inventory service section of the guide to Securing microservices with JSON Web Tokens].

=== Configure servlet security roles

The `@RolesAllowed` annotation typically specifies role-based access to back-end application resources, such as calls to a database.
To control authorization for front-end resources, such as HTTP calls, you can specify roles in the servlet code by configuring the `@ServletSecurity` annotation. You can specify the permissible roles with `rolesAllowed` attribute on the `@HttpConstraint` or `@HttpMethodConstraint` parameters. The `@HttpMethodConstraint` parameter specifies constraints for specific HTTP methods. The `@HttpConstraint` parameter specifies the default constraints for all HTTP methods that are not otherwise specified by the `@HttpMethodConstraint` parameter.

In the following example, the `@HttpConstraint` parameter specifies that all HTTP methods are constrained either to the `user` role or the `admin` role. The `@HttpMethodConstraint` parameter specifies that the `POST` method is constrained only to users who are in the `admin` role:

[source,java]
----
@ServletSecurity (value = @HttpConstraint(rolesAllowed = { "user", "admin" }),
  httpMethodConstraints = {@HttpMethodConstraint(value = "POST", rolesAllowed = {"admin"})})
----



For more information, see link:/guides/security-intro.html#adding-authentication-and-authorization[the Adding authentication and authorization section of the Securing a web application guide].


=== Authorize requests between web services

Authorization occurs not only between users and applications, but also between microservices within an application. When one service requests data from another, the requesting service often must demonstrate that it is authorized to access the data.
xref:single-sign-on.adoc#_json_web_token_jwt[Token-based authorization], such as with JSON Web Tokens (JWT), provides a lightweight way for security controls and security tokens to propagate user identities and roles across different services.
Open Liberty supports token-based authorization through the feature:jwt[display=MicroProfile JWT feature].

=== Configure authorization with a deployment descriptor file

Although annotations are the most common way to define roles in microservices, you can also define roles by specifying `security-constraint` elements in a `web.xml` deployment descriptor file.
This configuration might be necessary in situations where you want to keep the security configuration separate from the development environment and apply it at deployment time.

Some applications rely on a combination of declarative annotations and a deployment descriptor file. In these cases, deployment descriptor values supersede annotations.
Therefore, you can specify roles in a deployment descriptor file if you want to override security settings or defaults from elsewhere in the application code.
For more information, see link:/guides/security-intro.html#adding-authentication-and-authorization[the Adding authentication and authorization section of the Securing a web application guide].

=== Configure RunAs authentication

When a user is authenticated to a servlet, the servlet can make subsequent calls to downstream resources, such as other servlets. These subsequent calls are normally made under the same security roll and caller identity that was originally used to log in to the servlet. Alternatively, you can delegate any subsequent calls to a different security roll or caller identity by using the RunAs specification.

To use the RunAs specification, you must either specify the `@RunAs` annotation on a class in your application code or add the `run-as` element to your `web.xml` deployment descriptor file. In either case, you must set the annotation or element to the security role that you want to delegate to. You can also implement the RunAs specification in your server configuration to map a security role to a particular user.

For example, consider a servlet that requires either the `admin` or `user` role to authenticate. You can specify that subsequent calls from that servlet are run with the `admin` role by using the `@RunAs` annotation, as shown in the following example:

----
@RunAs("admin")
@RolesAllowed({ "admin", "user" })
----
For more information, see the xref:reference:javadoc/liberty-javaee8-javadoc.adoc#package=javax/annotation/security/package-frame.html&class=javax/annotation/security/RunAs.html[@RunAs annotation].

In the following `web.xml` file example, the `run-as` element specifies that the servlet makes calls under the `admin` role that is defined in the server configuration:

----
<servlet id="Servlet_1">
     <servlet-name>RunAsServlet</servlet-name>
     <display-name>RunAsServlet</display-name>
     <description>RunAsServlet</description>
     <servlet-class>web.RunAsServlet</servlet-class>
     <run-as>
          <role-name>admin</role-name>
     </run-as>
 </servlet>
----

To delegate calls that are made from a security roll to a particular caller identity, you can specify the `run-as` element in the security role configuration in your `server.xml' file. In this case, a specific set of user credentials is invoked whenever calls run under the specified role. For example, a servlet that requires an authenticated user to be in the `admin` role, needs to call to downstream resources that require credentials from a particular user, Wanda. You can set the `run-as` element on the `admin` security role to specify that calls made in that role invoke Wanda's credentials.

In the following `server.xml` file example, Wanda and Trevor are both in the `admin` security role. The `run-as` element specifies that calls from that role are run as Wanda:

----
<application-bnd>
      <security-role name="admin">
           <user name="Wanda" />
           <user name="Trevor" />
           <run-as userid="Wanda" password="{xor}Lz4sLCgwLTs="/>
       </security-role>
 </application-bnd>
----

If you configure the `run-as` element on a security role in your `server.xml` file, providing a password is optional. However, if this configuration is specified in an `ibm-application-bnd.xml` file, the password is required.

If you specify the `application-bnd` element in your server.xml file, your application must not be in the dropins folder. If you leave your application in the dropins folder, then you must disable application monitoring by adding the following code in your `server.xml` file:

----
<applicationMonitor dropinsEnabled="false" />
----

== See also

- Guide: link:/guides/security-intro.html[Securing a web application]
- Guide: link:/guides/microprofile-jwt.html[Securing microservices with JSON Web Tokens]
