:page-layout: general-reference
:page-type: general
:page-description: Observability helps you understand system behavior by processing and monitoring the data the system generates through metrics, logging, tracing, and health checks, to get the information you need to troubleshoot failure
:page-categories: MicroProfile
:seo-title: Observability helps you understand system behavior by processing and monitoring system data
:seo-description: Microservice architecture is a popular approach for building cloud-native applications in which each capability is developed as an independent service. It enables small, autonomous teams to develop, deploy, and scale their respective services independently.
= Observability and monitoring

Observability helps you understand system behavior by processing and monitoring the data that the system generates through metrics, logging, tracing, and health checks, to get the information you need to troubleshoot failure.

In a microservices environment, your application needs to be functional as a whole, though individual service instances can start or stop to adjust for capacity requirements or to recover from failure.
To monitor this fluid system each entity must provide appropriate data for problem detection.
Metrics collect numerical information from the application and platform, and logs collect textual information.
Tracing captures the end-to-end flow of a request through the system.
Health Checks help orchestrators perform automated actions to maintain overall system health.

== Metrics

Metrics are numerical measurements that are captured and processed to identify and respond to potential issues before they escalate and cause more serious problems.
In distributed system metrics, there are three factors involved; producers, aggregators, and processors.

Producers such as applications, can be directly involved in producing metrics. Also, other infrastructure might passively observe or actively instrument the application to produce metrics on its behalf.
The next action depends on the aggregator.

In the case of aggregators like Prometheus, metrics are transferred from the producer to the aggregator through either `push` or `pull` mechanisms.
Some aggregators, expect the application to connect to the aggregator to transmit data.
The connection information for the aggregator must be distributed to all of the application processes that are measured.
Other aggregators periodically connect to a known endpoint to gather metrics data.
This action requires the producer to define and provide an endpoint that can be scraped, and for the aggregator to be told where the endpoints are.
When used with Kubernetes, Prometheus can discover endpoints based on service annotations.

Processors like Grafana, use all of the aggregated data.
Grafana processes aggregated metrics for visualization by using dashboards.
Grafana also supports alerts by rules that are stored and evaluated independently of the dashboard.

== Logs

Log messages are strings with contextual information that pertains to the state and activity of a microservice when the log entry is created.
Logs are required to diagnose how and why services fail. They play a supporting role to metrics in monitoring application health.
Handling log files requires more thought if a containerized application can't be configured to write logs to `standard out` or `standard err` streams.
You can use a volume for log data with a simple bind mount for local development and test, or a proper Persistent Volume as part of a Kubernetes deployment.
A dedicated sidecar or logging agent can read from a shared volume to forward logs to a centralized aggregator.
Log rotation must be configured explicitly to control the amount of log data stored on volumes.
Alternately, you can use application libraries or agents to forward logs directly to aggregators.
This option can carry some configuration complexity across deployment environments.

== Tracing

Distributed, request, or end-to-end tracing captures the end-to-end flow of a request through the system.
Distributed tracing is a technique that addresses logging information in microservice-based applications.
HTTP request tracing helps to determine how a request is being processed.
This includes authentication and the length of each step that was taken in the pipeline.
Tracing essentially captures both relationships between services, the services the request touched, and the structure of work through the system, synchronous or asynchronous processing, child-of or follows-from relationships.

== Health Checks

A health check is a special REST API implementation that you can use to validate the status of a microservice and its dependencies.
Services report as either `UP` or `DOWN` state by implementing the API provided by MicroProfile Health.
Health Checks, often custom HTTP endpoints, help orchestrators, like Kubernetes or Cloud Foundry, to perform automated actions to maintain overall system health.

A service has a health check API endpoint, for example `HTTP /health`, that returns the health of the service.
The API endpoint handler performs various checks, such as the status of the connections to the infrastructure services used by the service instance.
The status of the host, for example, disk space, and application specific logic.

A health check client; a monitoring service, service registry or load balancer, periodically invokes the endpoint to check the health of the service instance
